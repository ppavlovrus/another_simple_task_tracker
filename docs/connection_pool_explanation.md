# Как работает Connection Pool в asyncpg

## Что такое Connection Pool?

**Connection Pool (пул соединений)** - это коллекция заранее созданных соединений с базой данных, которые переиспользуются между запросами.

### Аналогия из жизни:
Представь библиотеку:
- **Без пула**: каждый читатель идет в библиотеку, ждет, пока библиотекарь откроет дверь, берет книгу, возвращает, библиотекарь закрывает дверь. Медленно!
- **С пулом**: библиотекарь держит несколько дверей открытыми, читатели берут книги через открытые двери, возвращают, и двери остаются открытыми для следующих. Быстро!

---

## Как это работает в нашем коде

### 1. Создание пула при старте приложения

```python
@asynccontextmanager
async def lifespan(app: FastAPI):
    global db_pool
    
    # Создаем пул при старте приложения
    db_pool = await asyncpg.create_pool(
        DATABASE_URL,
        min_size=10,      # Минимум 10 соединений всегда открыты
        max_size=20,      # Максимум 20 соединений одновременно
        command_timeout=60,
        max_queries=50000,
        max_inactive_connection_lifetime=300.0,
    )
    
    yield  # Приложение работает здесь
    
    # Закрываем пул при остановке
    await db_pool.close()
```

**Что происходит:**
1. При старте приложения создается пул с **минимум 10 соединениями**
2. Эти соединения уже установлены и готовы к использованию
3. При остановке приложения все соединения закрываются

---

### 2. Использование соединения из пула

```python
async def get_db_connection() -> asyncpg.Connection:
    # Берем соединение из пула
    async with db_pool.acquire() as connection:
        yield connection
    # Соединение автоматически возвращается в пул
```

**Что происходит:**
1. `pool.acquire()` - берет одно свободное соединение из пула
2. Если все соединения заняты - ждет, пока одно освободится
3. После использования (`async with` завершается) - соединение возвращается в пул
4. Соединение НЕ закрывается, а остается в пуле для следующего запроса

---

### 3. Использование в endpoint

```python
@app.post("/tasks")
async def create_task(
    task: TaskCreate,
    conn: Annotated[asyncpg.Connection, Depends(get_db_connection)],
):
    # conn - это соединение из пула
    row = await conn.fetchrow("SELECT ...")
    # После завершения функции соединение возвращается в пул
```

---

## Параметры пула (что они означают)

### `min_size=10`
- **Минимум 10 соединений** всегда открыты и готовы
- Даже если нет запросов, эти 10 соединений ждут
- **Зачем:** быстрый отклик на первые запросы

### `max_size=20`
- **Максимум 20 соединений** одновременно
- Если все 20 заняты, новый запрос ждет освобождения
- **Зачем:** ограничение нагрузки на БД

### `command_timeout=60`
- Максимальное время выполнения одного SQL запроса (60 секунд)
- Если запрос выполняется дольше - выбрасывается исключение
- **Зачем:** защита от зависших запросов

### `max_queries=50000`
- Максимум запросов на одно соединение
- После 50000 запросов соединение пересоздается
- **Зачем:** избежать проблем с "устаревшими" соединениями

### `max_inactive_connection_lifetime=300.0`
- Если соединение не используется 300 секунд (5 минут) - закрывается
- **Зачем:** освобождение ресурсов неиспользуемых соединений

---

## Визуализация работы пула

```
┌─────────────────────────────────────┐
│      Connection Pool (10-20)        │
│  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐  │
│  │Conn1│ │Conn2│ │Conn3│ │ ... │  │
│  └─────┘ └─────┘ └─────┘ └─────┘  │
└─────────────────────────────────────┘
         ▲              │
         │              │
    acquire()      release()
         │              │
         ▼              ▼
    ┌─────────┐   ┌─────────┐
    │ Request │   │ Request │
    │   1     │   │   2     │
    └─────────┘   └─────────┘
```

### Пример работы:

1. **Запрос 1 приходит:**
   ```
   Request 1 → pool.acquire() → берет Conn1 → выполняет запрос → release() → Conn1 возвращается в пул
   ```

2. **Запрос 2 приходит (одновременно с 1):**
   ```
   Request 2 → pool.acquire() → берет Conn2 → выполняет запрос → release() → Conn2 возвращается в пул
   ```

3. **Запрос 3 приходит (когда все заняты):**
   ```
   Request 3 → pool.acquire() → ждет... → Conn1 освободился → берет Conn1 → выполняет → release()
   ```

---

## Сравнение: БЕЗ пула vs С пулом

### ❌ БЕЗ пула (старый код):

```python
async def create_task(task: TaskCreate):
    # Каждый раз создаем НОВОЕ соединение
    conn = await asyncpg.connect(DATABASE_URL)  # ~50-100ms на создание
    try:
        row = await conn.fetchrow("SELECT ...")  # ~10ms на запрос
    finally:
        await conn.close()  # ~10ms на закрытие
    # Итого: ~70-120ms на каждый запрос
```

**Проблемы:**
- Медленно: создание соединения занимает 50-100ms
- Нагрузка на БД: каждое соединение - это ресурс PostgreSQL
- Не масштабируется: при 100 запросах/сек создается 100 соединений/сек

### ✅ С пулом (новый код):

```python
async def create_task(task: TaskCreate, conn: Depends(get_db_connection)):
    # Берем готовое соединение из пула
    # conn уже готово, создано при старте приложения
    row = await conn.fetchrow("SELECT ...")  # ~10ms на запрос
    # Соединение автоматически возвращается в пул
    # Итого: ~10ms на запрос
```

**Преимущества:**
- Быстро: соединение уже готово, нет задержки на создание
- Эффективно: переиспользуем соединения
- Масштабируется: 20 соединений могут обработать сотни запросов/сек

---

## Жизненный цикл соединения в пуле

```
1. Создание пула (startup)
   ├─ Создается 10 соединений (min_size)
   ├─ Все соединения открыты и готовы
   └─ Ждут запросов

2. Запрос приходит
   ├─ pool.acquire() - берет свободное соединение
   ├─ Выполняется SQL запрос
   └─ Соединение возвращается в пул (НЕ закрывается!)

3. Если все соединения заняты
   ├─ Новый запрос ждет освобождения
   ├─ Если есть свободное место (меньше max_size) - создается новое
   └─ Иначе ждет освобождения существующего

4. Закрытие пула (shutdown)
   ├─ Все соединения закрываются
   └─ Ресурсы освобождаются
```

---

## Пример работы в реальном времени

### Сценарий: 5 одновременных запросов

```
Время 0ms:  Пул создан, 10 соединений готовы
            [Conn1, Conn2, Conn3, ..., Conn10] - все свободны

Время 1ms:  Request 1 → берет Conn1
            [Conn1(занят), Conn2, Conn3, ..., Conn10]

Время 2ms:  Request 2 → берет Conn2
            [Conn1(занят), Conn2(занят), Conn3, ..., Conn10]

Время 3ms:  Request 3 → берет Conn3
            Request 4 → берет Conn4
            Request 5 → берет Conn5
            [Conn1-5(заняты), Conn6-10(свободны)]

Время 50ms: Request 1 завершился → Conn1 возвращается в пул
            [Conn1(свободен), Conn2-5(заняты), Conn6-10(свободны)]

Время 60ms: Request 6 приходит → берет Conn1 (уже готов!)
            [Conn1(занят), Conn2-5(заняты), Conn6-10(свободны)]
```

**Без пула:** каждый запрос ждал бы 50-100ms на создание соединения  
**С пулом:** запрос сразу получает готовое соединение

---

## Важные моменты

### 1. Соединение НЕ закрывается после использования

```python
async with db_pool.acquire() as connection:
    # Используем соединение
    await connection.fetchrow("SELECT ...")
# Здесь соединение НЕ закрывается!
# Оно возвращается в пул и может быть использовано снова
```

### 2. Пул управляет соединениями автоматически

- Создает новые, если нужно (до max_size)
- Закрывает неиспользуемые (после max_inactive_connection_lifetime)
- Пересоздает "устаревшие" (после max_queries)

### 3. Блокировка при нехватке соединений

Если все 20 соединений заняты:
- Новый запрос **ждет** освобождения
- Это нормально и ожидаемо
- Можно увеличить `max_size` если нужно

---

## Почему это важно для production?

1. **Производительность:** в 5-10 раз быстрее, чем создание соединений
2. **Масштабируемость:** 20 соединений могут обработать тысячи запросов
3. **Надежность:** пул управляет соединениями, пересоздает при проблемах
4. **Эффективность:** меньше нагрузка на PostgreSQL

---

## В нашем коде

```python
# 1. При старте приложения создается пул
db_pool = await asyncpg.create_pool(...)  # 10-20 соединений готовы

# 2. В каждом запросе берем соединение из пула
async with db_pool.acquire() as conn:
    # Используем соединение
    await conn.fetchrow("SELECT ...")
# Соединение возвращается в пул

# 3. При остановке приложения пул закрывается
await db_pool.close()  # Все соединения закрываются
```

**Результат:** быстрые запросы, эффективное использование ресурсов, готовность к production нагрузке!


